<!doctype html>
<html lang="en" class="h-full w-full m-0">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <script src="https://cdn.jsdelivr.net/npm/p5@1.11.11/lib/p5.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <title>Snake</title>
  </head>
  <body
    class="h-full w-full m-0 bg-gradient-to-b from-gray-900 via-black to-gray-900"
  >
    <div
      id="mainDiv"
      class="h-full flex flex-col justify-center items-center font-mono text-white"
    >
      <div
        id="topBar"
        class="flex w-full justify-between items-center bg-black h-10 px-2"
      >
        <div>Speed: <span id="speed" class="text-center"></span></div>
        <div>Score: <span id="score" class="text-center"></span></div>
        <div class="flex items-center">
          Level: <span id="level" class="w-8 text-center"></span>
        </div>
      </div>
      <div
        id="menu"
        class="absolute border-2 rounded-lg font-bold border-black bg-gradient-to-b from-black via-gray-900 to-black w-56 h-64 p-4"
      >
        <div class="flex justify-center text-2xl text-[green]">
          <span class="pr-4 flex items-center">
            <span
              class="rounded-full bg-[red] h-3 w-3 border border-red-500 animate-[bounce_1.2s_ease-in-out_infinite]"
            ></span
          ></span>
          <span class="animate-[bounce_1.2s_linear_infinite_-0.2s]">S</span>
          <span class="animate-[bounce_1.2s_linear_infinite_-0.4s]">n </span>
          <span class="animate-[bounce_1.2s_linear_infinite_-0.6s]">a </span>
          <span class="animate-[bounce_1.2s_linear_infinite_-0.8s]">k </span>
          <span class="animate-[bounce_1.2s_linear_infinite_-1s]">e </span>
        </div>
        <div id="menuButtons" class="mt-4 flex flex-col items-center gap-2">
          <div id="play" class="hover:text-[darkgreen] cursor-pointer">
            Play
          </div>
          <div id="settings" class="hover:text-[darkgreen] cursor-pointer">
            Settings
          </div>
        </div>

        <div id="settingsField" class="flex flex-col justify-center gap-1">
          <div class="flex items-center gap-2">
            Cell size:
            <img
              id="cellSize"
              value="minus"
              src="arrow.svg"
              class="rotate-180 cursor-pointer"
            />
            <div id="cellSizeValue"></div>
            <img
              id="cellSize"
              value="plus"
              src="arrow.svg"
              class="cursor-pointer"
            />
          </div>

          <div class="flex items-center gap-2">
            Snake:
            <input
              type="color"
              id="snakeColor"
              value="#0000ff"
              class="w-[20px] h-[20px]"
            />
          </div>
          <div class="flex items-center gap-2">
            Food:
            <input
              type="color"
              id="foodColor"
              value="#ff0000"
              class="w-[20px] h-[20px]"
            />
          </div>
          <div class="flex items-center gap-2">
            Board:
            <input
              type="color"
              id="boardColor1"
              value="#0000ff"
              class="w-[20px] h-[20px]"
            />
            <input
              type="color"
              id="boardColor2"
              value="#0000ff"
              class="w-[20px] h-[20px]"
            />
          </div>
          <div
            id="wallCollisionToggle"
            class="flex items-center gap-1 cursor-pointer"
          >
            Wall Collision: <span id="wallCollisionValue"></span>
          </div>

          <div
            id="returnToMenu"
            class="flex items-center cursor-pointer justify-center mt-2"
          >
            Return to Menu
          </div>
        </div>
        <div id="gameOver" class="text-center flex flex-col">
          <div id="gameOverText" class="mt-2"></div>
          <div class="text-orange-400 mt-1 flex gap-1 justify-center">
            Score:<span id="gameOverScore"></span>
          </div>
          <div id="goToMenu" class="mt-4 cursor-pointer hover:text-[darkgreen]">
            Go to menu
          </div>
          <div
            id="playAgain"
            class="mt-2 cursor-pointer text-green-500 hover:text-[darkgreen]"
          >
            Play again!
          </div>
        </div>
      </div>

      <canvas id="game"></canvas>
      <div
        class="flex flex-col justify-center items-center w-full gap-1 mt-1"
        id="gameControls"
      >
        <div>
          <img
            value="up"
            src="arrowLg.svg"
            class="-rotate-90 cursor-pointer active:scale-[95%]"
          />
        </div>

        <div class="flex flex-row justify-center items-center gap-1">
          <img
            value="left"
            src="arrowLg.svg"
            class="rotate-180 cursor-pointer w-fit active:scale-[95%]"
          />
          <img
            value="down"
            src="arrowLg.svg"
            class="rotate-90 cursor-pointer active:scale-[95%]"
          />
          <img
            value="right"
            src="arrowLg.svg"
            class="cursor-pointer active:scale-[95%]"
          />
        </div>
      </div>
    </div>

    <script>
      const canvas = document.getElementById("game");

      let play = false;
      let settings = false;

      const menu = document.getElementById("menu");
      const menuButtons = document.getElementById("menuButtons");
      const mainDiv = document.getElementById("mainDiv");
      const settingsField = document.getElementById("settingsField");
      const gameOverField = document.getElementById("gameOver");
      const gameOverScore = document.getElementById("gameOverScore");
      const gameOverText = document.getElementById("gameOverText");

      const cellSizeValue = document.getElementById("cellSizeValue");
      const snakeColorInput = document.getElementById("snakeColor");
      const foodColorInput = document.getElementById("foodColor");
      const boardColorInput1 = document.getElementById("boardColor1");
      const boardColorInput2 = document.getElementById("boardColor2");
      const wallCollisionToggle = document.getElementById(
        "wallCollisionToggle",
      );
      const wallCollisionValue = document.getElementById("wallCollisionValue");

      const topBarField = document.getElementById("topBar");
      const scoreField = document.getElementById("score");
      const levelField = document.getElementById("level");
      const speedField = document.getElementById("speed");
      const gameControlsField = document.getElementById("gameControls");

      document.addEventListener("visibilitychange", (event) => {
        if (document.visibilityState === "hidden") {
          mainDiv.appendChild(menu);
          play = false;
        }
      });

      // addEventListener
      const addEvent = (id, type, func) => {
        document.getElementById(id).addEventListener(type, func, false);
      };

      // addEventListener
      const removeEvent = (id, type, func) => {
        document.getElementById(id).addEventListener(type, func, false);
      };

      const handleMenuClicks = () => {
        addEvent("play", "click", () => {
          if (isGameOver()) {
            setup();
          }

          menu.remove();
          play = true;
        });

        addEvent("playAgain", "click", () => {
          setup();
          settingsField.remove();
          gameOverField.remove();
          menu.appendChild(menuButtons);
          menu.remove();
          play = true;
        });

        addEvent("returnToMenu", "click", () => {
          settingsField.remove();
          menu.appendChild(menuButtons);
        });

        // when in game over screen
        addEvent("goToMenu", "click", () => {
          settingsField.remove();
          gameOverField.remove();
          menu.appendChild(menuButtons);
        });

        addEvent("settings", "click", () => {
          menuButtons.remove();
          menu.appendChild(settingsField);
        });

        document.querySelectorAll("[id=cellSize]").forEach((img) => {
          img.addEventListener("mousedown", (event) => {
            const isPlus = event.target.getAttribute("value") === "plus";
            let temp = cell + (isPlus ? +1 : -1);
            // calculate next right size board
            while (canvasSize % temp !== 0) {
              isPlus ? temp++ : temp--;
            }

            if (temp > 200 || temp < 5) return;
            BOARD_HEIGHT = Math.floor(canvasSize / temp);
            BOARD_WIDTH = Math.floor(canvasSize / temp);
            cellSizeValue.innerText = cell = temp;
            setup();
          });
        });

        document.querySelectorAll("[id=gameControls]").forEach((img) => {
          img.addEventListener("click", (event) => {
            setDirection(event.target.getAttribute("value"));
          });
        });

        addEvent("boardColor1", "input", () => {
          boardColor1 = boardColorInput1.value;
          drawBoard();
        });
        addEvent("boardColor2", "input", () => {
          boardColor2 = boardColorInput2.value;
          drawBoard();
        });

        addEvent("snakeColor", "input", () => {
          snakeColor = snakeColorInput.value;
          drawBoard();
        });

        addEvent("foodColor", "input", () => {
          foodColor = foodColorInput.value;
          drawBoard();
        });

        addEvent("wallCollisionToggle", "click", () => {
          wallCollision = !wallCollision;
          document.getElementById("wallCollisionValue").innerText =
            wallCollision ? " on " : " off ";
        });

        // **** Settings ends **** //
      };

      handleMenuClicks();
      gameOverField.remove();
      settingsField.remove();

      const handleKeyPresses = () => {
        document.addEventListener("keydown", (event) => {
          if (!play) return;

          const keyName = event.key;

          if (keyName === "Escape") {
            mainDiv.appendChild(menu);
            play = false;
          }
          setDirection(keyName);
        });
      };

      handleKeyPresses();

      const setDirection = (type) => {
        if (
          ("ArrowLeft" === type || "left" === type || "a" === type) &&
          isValidDirection("LEFT")
        ) {
          direction = "LEFT";
        }
        if (
          ("ArrowRight" === type || "right" === type || "d" === type) &&
          isValidDirection("RIGHT")
        ) {
          direction = "RIGHT";
        }
        if (
          ("ArrowUp" === type || "up" === type || "w" === type) &&
          isValidDirection("UP")
        ) {
          direction = "UP";
        }
        if (
          ("ArrowDown" === type || "down" === type || "s" === type) &&
          isValidDirection("DOWN")
        ) {
          direction = "DOWN";
        }
      };

      let cell = 50;
      let board;
      let canvasSize = 500;
      let BOARD_HEIGHT = Math.floor(canvasSize / cell);
      let BOARD_WIDTH = Math.floor(canvasSize / cell);

      let boardColor1 = "#008000";
      let boardColor2 = "#006400";
      let snakeColor = "#0000FF";
      let foodColor = "#ff0000";

      let snake;
      let food;

      let stepsPerSecond = 5;
      let direction = "UP";
      let acc = 0;
      let score = 0;
      let level = 1;
      let wallCollision = true;

      const appleBite = new Audio("./crunchybite.ogg");
      const bumb = new Audio("./bumb.wav");

      const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      const source = audioCtx.createMediaElementSource(appleBite);
      source.connect(audioCtx.destination);

      const source1 = audioCtx.createMediaElementSource(bumb);
      source1.connect(audioCtx.destination);

      const initInnerTexts = () => {
        cellSizeValue.innerText = cell;
        boardColorInput1.value = boardColor1;
        boardColorInput2.value = boardColor2;
        snakeColorInput.value = snakeColor;
        foodColorInput.value = foodColor;
        scoreField.innerText = score;
        levelField.innerText = level;
        speedField.innerText = stepsPerSecond;
        wallCollisionValue.innerText = wallCollision ? " on " : " off ";
      };
      initInnerTexts();

      const generateEmptyBoard = () => {
        board = Array.from({ length: BOARD_HEIGHT }, () =>
          Array(BOARD_WIDTH).fill(0),
        );
      };

      function setup() {
        frameRate(30);
        canvasSize = window.innerWidth > 500 ? 500 : window.innerWidth;
        createCanvas(canvasSize, canvasSize, canvas);

        while (canvasSize % cell !== 0) {
          cell--;
        }

        BOARD_HEIGHT = Math.floor(canvasSize / cell);
        BOARD_WIDTH = Math.floor(canvasSize / cell);
        topBarField.style.width = canvasSize + "px";
        gameControlsField.style.width = canvasSize + "px";

        stepsPerSecond = Math.round(250 / cell);
        describe("Snake");
        generateEmptyBoard();
        generateSnake();
        generateFood();
        score = 0;
        acc = 0;
        level = 1;
        direction = "UP";
        initInnerTexts();
        drawBoard();
      }

      function draw() {
        if (!play) return;

        acc += deltaTime / 1000;
        if (acc >= 1 / stepsPerSecond) {
          move();
          acc -= 1 / stepsPerSecond;
        }

        if (isGameOver()) {
          gameOver();
          return;
        }

        levelUp();

        updateTopBar();
        drawBoard();
      }

      const drawBoard = () => {
        board.forEach((array, y) => {
          array.forEach((element, x) => {
            stroke(0);
            fill((y + x) % 2 === 0 ? boardColor1 : boardColor2);
            rect(x * cell, y * cell, cell, cell);

            drawSnake(y, x);
            drawFood(y, x);
          });
        });
      };

      const move = () => {
        const newHead = { ...snake[0] };

        if (direction === "UP") newHead.y -= 1;
        if (direction === "DOWN") newHead.y += 1;
        if (direction === "LEFT") newHead.x -= 1;
        if (direction === "RIGHT") newHead.x += 1;

        if (!wallCollision) {
          if (newHead.y >= BOARD_HEIGHT) newHead.y = 0;
          if (newHead.y < 0) newHead.y = BOARD_HEIGHT;
          if (newHead.x >= BOARD_WIDTH) newHead.x = 0;
          if (newHead.x < 0) newHead.x = BOARD_WIDTH;
        }

        snake.unshift(newHead);
        if (canEatFood(newHead)) {
          appleBite.play();
          score += 10;
          generateFood();
        } else {
          snake.pop();
        }
      };

      const isValidDirection = (direction) => {
        if (snake.length < 2) return true;

        if (direction === "LEFT") return snake[0].x - 1 !== snake[1].x;
        if (direction === "RIGHT") return snake[0].x + 1 !== snake[1].x;
        if (direction === "UP") return snake[0].y - 1 !== snake[1].y;
        if (direction === "DOWN") return snake[0].y + 1 !== snake[1].y;
      };

      const generateSnake = () => {
        let te = Math.floor(BOARD_WIDTH / 2);
        snake = [
          { x: Math.floor(BOARD_WIDTH / 2), y: Math.floor(BOARD_HEIGHT / 2) },
        ];
      };

      const generateFood = () => {
        const totalCells = BOARD_WIDTH * BOARD_HEIGHT;
        const occupied = new Set(
          snake.map((seg) => seg.y * BOARD_WIDTH + seg.x),
        );

        const freeCells = [];

        for (let i = 0; i < totalCells; i++) {
          if (!occupied.has(i)) {
            freeCells.push(i);
          }
        }

        if (freeCells.length === 0) {
          victory();
          return;
        }

        const index = freeCells[Math.floor(Math.random() * freeCells.length)];

        food = {
          x: index % BOARD_WIDTH,
          y: Math.floor(index / BOARD_WIDTH),
        };
      };

      const levelUp = () => {
        stepsPerSecond = stepsPerSecond + Math.floor(score / (100 * level));
        level = 1 + Math.floor(score / 100);
      };

      const victory = () => {
        food = { x: null, y: null };
        mainDiv.appendChild(menu);
        menuButtons.remove();
        menu.appendChild(gameOverField);
        gameOverScore.innerText = score;
        gameOverText.innerText = "Victory!";
        gameOverText.classList.remove("text-red-500");
        gameOverText.classList.add("text-green-500");
        play = false;
      };

      const canEatFood = (head) => {
        return head.x === food.x && head.y === food.y ? true : false;
      };

      const updateTopBar = () => {
        scoreField.innerText = score;
        speedField.innerText = stepsPerSecond;
        levelField.innerText = level;
      };

      const isGameOver = () => {
        if (
          (snake[0].x < 0 ||
            snake[0].x >= BOARD_WIDTH ||
            snake[0].y < 0 ||
            snake[0].y >= BOARD_HEIGHT) &&
          wallCollision
        ) {
          return true;
        }

        if (
          snake
            .slice(1)
            .some((part) => part.x === snake[0].x && part.y === snake[0].y)
        ) {
          return true;
        }

        return false;
      };

      const gameOver = () => {
        bumb.play();
        mainDiv.appendChild(menu);
        menuButtons.remove();
        menu.appendChild(gameOverField);
        gameOverText.innerText = "Game Over!";
        gameOverText.classList.remove("text-green-500");
        gameOverText.classList.add("text-red-500");
        gameOverScore.innerText = score;
        play = false;
      };

      const drawSnakeEyes = (x, y) => {
        const dx = food.x - snake[0].x;
        const dy = food.y - snake[0].y;
        const distance = Math.sqrt(dx * dx + dy * dy);

        const dirX = dx / distance;
        const dirY = dy / distance;

        const eyeSize = cell * 0.4;
        const pupilSize = cell * 0.25;
        const pupilOffset = Math.round(cell / 10);

        const f = cell / 2;
        const f2 = cell / 4;
        const f3 = cell * 0.75;

        if (direction === "LEFT" || direction === "RIGHT") {
          const eyeX = x * cell + f;
          const eyeY1 = y * cell + f2;
          const eyeY2 = y * cell + f3;

          fill("black");
          circle(eyeX, eyeY1, eyeSize, eyeSize);
          circle(eyeX, eyeY2, eyeSize, eyeSize);

          const pupilX = eyeX + dirX * pupilOffset;
          const pupilY = eyeY1 + dirY * pupilOffset;
          const pupilY2 = eyeY2 + dirY * pupilOffset;

          fill("white");
          circle(pupilX, pupilY, pupilSize, pupilSize);
          circle(pupilX, pupilY2, pupilSize, pupilSize);
        } else {
          const eyeX1 = x * cell + f2;
          const eyeX2 = x * cell + f3;
          const eyeY = y * cell + f;

          fill("black");
          circle(eyeX1, eyeY, eyeSize, eyeSize);
          circle(eyeX2, eyeY, eyeSize, eyeSize);

          const pupilY = eyeY + dirY * pupilOffset;
          const pupilX = eyeX1 + dirX * pupilOffset;
          const pupilX2 = eyeX2 + dirX * pupilOffset;
          fill("white");
          circle(pupilX, pupilY, pupilSize, pupilSize);
          circle(pupilX2, pupilY, pupilSize, pupilSize);
        }
      };

      const drawSnake = (y, x) => {
        if (snake.some((part) => part.x === x && part.y === y)) {
          fill(snakeColor);
          rect(x * cell, y * cell, cell, cell);

          if (snake[0].x === x && snake[0].y === y) {
            drawSnakeEyes(x, y);
          }
        }
      };

      const drawFood = (y, x) => {
        if (x === food.x && y === food.y) {
          fill(foodColor);
          rect(x * cell, y * cell, cell, cell);
        }
      };
    </script>
  </body>
</html>
